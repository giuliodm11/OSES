
# OSES - Embedded Operating Systems Labs

This repository contains a series of practical exercises on Embedded Operating Systems, based on Trampoline OS and Python scripts for building and trace analysis.

## Repository Structure

- **lab00.pdf, lab01.pdf, ...**: Theoretical material and lab instructions.
- **script/**: Main folder with sources, build scripts, and configuration for each lab.
    - Each subfolder (`lab01_ex01`, `lab01_ex02`, etc.) contains:
        - C/C++ sources and OIL configuration files.
        - Python scripts (`build.py`, `make.py`, `readTrace.py`) for building and analysis.
        - Trace files (`trace.json`) and simulation outputs.

## Example: script/lab01_ex01

- **lab01_ex01.c**: Source code with periodic tasks and alarm management.
- **lab01_ex01.oil**: Trampoline OS configuration (stack, alarms, build).
- **build.py / make.py**: Scripts generated by goil for building.
- **readTrace.py**: Analysis of traces generated by the application.
- **trace.json**: Example trace in JSON format.

## Build and Analysis

1. Edit the OIL file if needed.
2. Run `python make.py` to generate build files.
3. Run `python build.py` to compile the application.
4. Analyze traces with `python readTrace.py -i trace.json -a load`.


## Lab Details

### lab01_ex01
- **Goal:** Introduction to Trampoline OS with periodic tasks and alarms.
- **What was done:** Implemented two periodic tasks (`TaskA` and `TaskB`) activated by alarms at different intervals (500ms and 750ms). A third task (`stop`) cancels the alarms. Demonstrates basic OS startup and alarm management.

### lab01_ex02
- **Goal:** Use Trampoline OS with Arduino hardware.
- **What was done:** Two tasks toggle a digital pin (LED) and print timestamps to the serial monitor. Alarms activate tasks periodically. Demonstrates integration of Trampoline OS with Arduino functions and serial communication.

### lab02_ex01
- **Goal:** Task communication and input handling.
- **What was done:** Multiple tasks read analog and digital inputs, use alarms for periodic activation, and exchange messages. Demonstrates inter-task communication, input reading, and conditional logic based on hardware state.

### lab3.2
- **Goal:** Resource management and task timing.
- **What was done:** Tasks use OS resources (mutexes) to protect shared data and simulate workload with delays. Alarms activate tasks at different intervals. Demonstrates resource acquisition/release and timing analysis.

### lab3.3
- **Goal:** Message passing between tasks.
- **What was done:** Tasks send and receive messages, handle errors, and synchronize using OS primitives. Demonstrates message-based communication and error handling in a multitasking environment.

### lab4.1
- **Goal:** Circular buffer and sensor data acquisition.
- **What was done:** Tasks read sensor values into a circular buffer, using resources for safe access. Alarms control periodic sampling. Demonstrates buffer management, resource protection, and analog input handling.

### lab4.2
- **Goal:** Advanced buffer management and task coordination.
- **What was done:** Similar to lab4.1, but with more complex logic for writing and reading from the buffer, and additional coordination between tasks. Demonstrates advanced buffer operations and inter-task synchronization.

### lab4.3
- **Goal:** Task scheduling and buffer operations.
- **What was done:** Tasks perform periodic operations, manage a circular buffer, and use alarms for scheduling. Demonstrates scheduling strategies and buffer usage in a real-time context.

### lab5.1
- **Goal:** High-frequency data acquisition and queue management.
- **What was done:** Tasks sample sensor data at high frequency (20ms), store in a large circular buffer, and manage a queue for processing. Demonstrates real-time data acquisition, buffer overflow handling, and queue management.

---
For details on each lab, refer to the corresponding PDF and the folder in `script/`.
